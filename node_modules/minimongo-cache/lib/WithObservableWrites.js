var EventEmitter, NullTransaction, WithObservableWrites, WriteTransaction, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

EventEmitter = require('eventemitter3');

NullTransaction = require('./NullTransaction');

_ = require('lodash');

WriteTransaction = (function(_super) {
  __extends(WriteTransaction, _super);

  function WriteTransaction(db) {
    this.db = db;
    this.dirtyIds = {};
    this.queued = false;
  }

  WriteTransaction.prototype._ensureQueued = function() {
    if (!this.queued) {
      this.queued = true;
      return process.nextTick((function(_this) {
        return function() {
          return _this._flush();
        };
      })(this));
    }
  };

  WriteTransaction.prototype.upsert = function(collectionName, result, docs) {
    if (!Array.isArray(docs)) {
      docs = [docs];
    }
    this.dirtyIds[collectionName] = this.dirtyIds[collectionName] || {};
    docs.forEach((function(_this) {
      return function(doc) {
        return _this.dirtyIds[collectionName][doc._id] = true;
      };
    })(this));
    this._ensureQueued();
    return result;
  };

  WriteTransaction.prototype.del = function(collectionName, result, id) {
    this.dirtyIds[collectionName] = this.dirtyIds[collectionName] || {};
    this.dirtyIds[collectionName][id] = true;
    this._ensureQueued();
    return result;
  };

  WriteTransaction.prototype.canPushTransaction = function(transaction) {
    return true;
  };

  WriteTransaction.prototype._flush = function() {
    var changeRecords, collectionName, documentFragments, id, ids, version, _ref;
    changeRecords = {};
    _ref = this.dirtyIds;
    for (collectionName in _ref) {
      ids = _ref[collectionName];
      documentFragments = [];
      for (id in ids) {
        version = this.db.collections[collectionName].versions[id];
        documentFragments.push({
          _id: id,
          _version: version
        });
      }
      changeRecords[collectionName] = documentFragments;
    }
    this.dirtyIds = {};
    this.queued = false;
    return this.db.emit('change', changeRecords);
  };

  return WriteTransaction;

})(NullTransaction);

WithObservableWrites = {
  getDefaultTransaction: function() {
    this.setMaxListeners(0);
    return new WriteTransaction(this);
  }
};

_.mixin(WithObservableWrites, EventEmitter.prototype);

module.exports = WithObservableWrites;
